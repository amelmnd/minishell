23/11/2023 14h10
On vire get_next_line du coup ?

18/11/2023 21h17

Penser à sécuriser pwd et env avec le protection du code des fonctions dans des if
tels que :
if (msh && exec_list_node)
C'est pour éviter les segfaults

Retoucher env pour prendre en compte ceci :
il est possible d'export des variables sans valeur
export les affiche
env ne les affiche pas

'export lol' ajoute une variable sans valeur
'export lol=' ajoute une variable avec valeur

la variable d'environnement _ est affichée par env, mais pas part export

au moment de l'export : s'il y a un =, une chaine vide est associée au nom
la variable est affichée par export tel que : nom_var=""
la variable est affichée par env tel que : nom_var=


11/11/2023 à 9h04
L'expander conserve les s_quote et d_quote vides, ce qui est un très bonne chose
Pendant les retouches de l'expander, il faut que ça soit toujours le cas !

11/11/2023 à 06h49
Deux sujets au niveau de l'expander :
- Pour les ambiguous_redirect, il faut non seulement prendre en compte les variables
inexistantes, mais aussi les variables spéciales
- En réfléchissant aux fonctions env, export et unset, puis à l'expander, je me suis dit
qu'il valait mieux régler ces trois builtins avant de retoucher l'expander ; je m'explique :
L'expander va, notamment pour (tenter de) remplacer les variables par leur valeur,
interroger l'environnement de minishell, lequel sera (potentiellement) modifié au fil
des itérations successives après un même démarrage du programme.
L'environnement doit également pouvoir être affiché de deux manières différentes :
	- avec le builtin env ; les variables affichées dans un ordre un peu aléatoire
	- avec le builtin export (sans argument) ; avec :
		- les variables natives en premier, triées dans l'ordre lexicographique
		- les variables ajoutées (par export), en second, triées dans l'ordre lexicographique
Il faut donc être capable de distinguer les deux types de variable : natives et ajoutées.
Tu avais proposé l'utilisation de deux listes chainées différentes ; ce qui permettrait
aisément la distinction entre natives et ajoutées ; je pense que cette solution à deux
listes est une bonne idée.
Cependant, elle a une implication au niveau de l'expander :
	l'expander devra donc interroger ces deux listes pour tenter de remplacer les variables
	par leur valeur.
Concernant unset : il faudra interroger les deux listes aussi.

10/11/2023 à 18h35
Les erreurs classiques des redirections sont maintenant gérées
Il manque cependant les erreurs provoquées par les variables inexistantes ou spéciales
Je réalise que je perds une information lors de l'expander (que je ne peux pas récupérer
à l'exécuteur, vu que la fusion est passée par là)
En fait, il me faudrait une nouvelle entrée dans l'e_expander_type :
enum	e_expander_type
{
	INIT_VALUE_EXP_CURRENT_TYPE,
	WORD_EXPANDED,
	R_ORIGIN_REDIRECT,
	LIMITER_HEREDOC,
	W_DEST_REDIRECT,
	WA_DEST_REDIRECT,
	PIPE_EXPANDED,
	HEREDOC_ERASED,
->	AMBIGUOUS_REDIRECT <-
};
Cette valeur de l'enum serait attribuée au noeud de l'exp_list correspondant dans le cas
suivant :
une fusion n'est le produit que d'une seule variable qui n'existe pas.
Dans ce cas, le nom de la variable doit être conservée (ce qui est déjà le cas, et tant mieux),
mais je ne sais pas, dans le cas d'une redirection, s'il s'agit d'un nom de variable
inexistante, ou si c'était le contenu d'une s_quote, ou encore le résultat d'une fusion de
plusieurs mots/caractères

Tests autour des variables inexistantes et des ambiguous_redirect :
bash 3.2: > $lol                                                                    
bash: $lol: ambiguous redirect
bash 3.2: < $lol$mdr                                                                
bash: $lol$mdr: ambiguous redirect
bash 3.2: < $lol""$mdr                                                              
bash: : No such file or directory
bash 3.2: < "$lol"                                                                  
bash: : No such file or directory
bash 3.2: < $lol                                                                    
bash: $lol: ambiguous redirect
bash 3.2: < $lol$mdr                                                                
bash: $lol$mdr: ambiguous redirect
bash 3.2: < $"lol"$mdr                                                              
bash: lol: No such file or directory
bash 3.2: < "$lol"$mdr                                                              
bash: : No such file or directory
bash 3.2: < "$lol$mdr"                                                              
bash: : No such file or directory
bash 3.2: < $lol""                                                                  
bash: : No such file or directory
bash 3.2: < ""$lol                                                                  
bash: : No such file or directory
bash 3.2: < ''$lol                                                                  
bash: : No such file or directory
bash 3.2: < $lol''                                                                  
bash: : No such file or directory

(copié collé des messages discords explicatifs)
En fait, tu as fait en sorte que les variables inexistantes disparaissent lorsqu'elles ne 
sont pas l'objet de redirection. Aucun problème de ce côté là, c'est ce qu'o navait prévu, 
et rien à retoucher là-dessus
On avait aussi prévu de conserver le nom de la variable dans le cas où elle n'existe pas,
 et qu'elle est l'objet d'une redirection ; ça aussi c'est ce que l'on avait prévu,
  et c'est comme ça que ça foncitonne, et tant mieux aussi
Là où j'ai un problème, c'est qu'une fois à l'exécutor, je ne sais pas distinguer 
les deux cas suivants (par exemple) :
(la variable lol n'existe pas)
< '$lol'
ET
< $lol
l'expander me sort la même chose en terme de texte, et c'est ce que l'on veut
Par contre, dans le premier cas, l'executor doit lire à partir du fichier nommé $lol
Alors que dans le deuxième cas, l'executor doit retourner une erreur "ambiguous redirect"
(Je me suis fait un peu mieux comprendre ?)
Donc, dans le cas où tu reçois < $lol dans l'expander, 
tu conserves toujours le nom de la variable inexistante (rien à changer de ce côté-là),
 mais au lieu de mettre l'enum     R_ORIGIN_REDIRECT, 
 tu mettrais un nouveau AMBIGUOUS_REDIRECT
amel — Aujourd’hui à 18:55
Ok mais c'est pour quel chevrons qu'on dooit faire ca ?
Spardaspirit — Aujourd’hui à 18:55
tous sauf <<


9/11/2023 à 18h38

au démarrage : msh->return_code est à 0
lexer :
	si erreur :
		msh->return_code est modifié à 2
		pas de parser, expander ni executor
		à la nouvelle itération msh->return_code est donc toujours à 2
	sinon
		msh->return_code laissé à 0
parser :
	même chose que le lexer
expander :
	si on parvient jusqu'à l'expander, alors, $? est remplacé par sa valeur
executor :
	si erreur :
		affichage de l'erreur (qui peut contenir l'actuelle valeur de msh->return_code)
		msh->return_code est assigné à l'erreur correspondante





9/11/2023 à 16h05
Certes, << $toto entraine une erreur qui fait crash
mais $toto aussi :/


9/11/2023 : Signaux
En mode interactif, le sujet précise déjà les comportements des trois signaux ;
Ctrl + C :
	(free entre deux itérations)
	affiche à nouveau le prompt
	msh->return_code assigné à 130
Ctrl + D :
	(free de TOUT)
	quitte minishell
	(question du msh->return_code non pertinente)
Ctrl + \ :
	RIEN
	msh->return_code laissé à 0

Pendant l'exécution :
Ctrl + C : 
	(free entre deux itérations)
	interrompt (kill certainement) tous les processus en cours
	affiche à nouveau le prompt
	msh->return_code assigné à 130
Ctrl + D :
	RIEN
	msh->return_code laissé à 0
Ctrl + \ :
	même chose que Ctrl + C, sauf le msh->return_code assigné à 131

Pendant la saisie d'un heredoc :
Ctrl + C :
	Même chose que pendant l'exécution
Ctrl + D :
	Même chose que Ctrl + C, sauf le msh->return_code laissé à 0
Ctrl + \ :
	RIEN (la saisie du heredoc est maintenue, sans nouvelle ligne)
	Après la saisie du limiter, msh->return_code est toujours à 0



<> est un opérateur de redirection "lecture-écriture" ; après relecture attentive du sujet, il n'est pas à implémenter, contrairement à ce que les tests des pages github peuvent sous-entendre
Ainsi, <> doit provoquer une syntax error chez nous
Je crois que nous l'avions déjà noté, mais au cas où, un rappel (vu que je suis tombé dessus dans les tests sur github).

ls|cat ne fonctionne pas :
	le pipe n'est pas pris en compte
	l'expander sort juste deux mots d'affilée

Les commandes suivantes :

- première commande : ls > lol
spardaspirit $> ls > lol
(WORD_EXPANDED)ls (W_DEST_REDIRECT)lol 
spardaspirit $> Segmentation fault (core dumped)
// le Segmentation fault (core dumped) s'affiche tout seul dans le prompt,
// je ne l'ai pas saisi

- deuxième commande : echo coucou > mdr
(même erreur)

provoquent une segfault au moment du réaffichage du prompt
valgrind indique une anomalie du ft_strlen (ah ouais, à ce point ???)
cela semble être uniquement le cas des lignes ne contenant aucun pipe
dès qu'il y au moins un pipe, la segfault n'apparait plus


Contenu de notes.txt (fichier maintenant supprimé) collé ici :
A adapter et incure dans chaque fichier

#include "minishell.h"




Observations expander test:

//arrive lors de la première saisie de prompt, mais pas durant les suivantes
spardaspirit $> e'c'ho lol
str = c
Segmentation fault (core dumped)

// pareil, lors de la première saisie, mais pas durant les suivantes
spardaspirit $> lol lol
Segmentation fault (core dumped)

Hypothèse : s'il y a plus de deux mots dans le premier prompt : segfault


// un seul chevron ouvert provoque une segfault,
	même après plusieurs saisies d'autres prompts précédents
spardaspirit $> <

______ main lexer_list ______
str -> [<]
type -> R_REDIRECT

***********
bash: syntax error near unexpected token 'newline'
Segmentation fault (core dumped)


//même problème ici
spardaspirit $> <<

______ main lexer_list ______
str -> [<<]
type -> HEREDOC

***********
bash: syntax error near unexpected token 'newline'
Segmentation fault (core dumped)

// tous les chevrons provoquent le même type d'erreur menant à une segfault


spardaspirit $> lol

______ main lexer_list ______
str -> [lol]
type -> WORD

***********

______ main expander_list ______
str -> [lol]
type -> WORD_EXPANDED
***********
spardaspirit $> > lol

______ main lexer_list ______
str -> [>]
type -> W_REDIRECT

str -> [ ]
type -> BLANK
Segmentation fault (core dumped)


Après de nombreux tests durant une même exécution (donc après plusieurs saisies successives de prompts),
	les chevrons tout seul fonctionnent


Je remarque aussi que l'expander ne s'affiche plus.
En regardant le main.c,
	je remarque que le parser et l'expander ne se déclenchent que selon la valeur d'une variable dans msh qui ne semble pas initialisée.
La valeur de cette variable n'est ajustée que dans le lexer (lexer_create_list),
	et dans le parser. Elle n'est pas initialisée à la création de la structure msh.


spardaspirit $> cd lol $coucou 'cou'$lol <hou >>lol <d <j>l  (#) | allo 'cou$tata' "agrougrou$pouah$akiya"
str = cou
str = cou$tata

______ main lexer_list ______
str -> [cd]
type -> WORD

str -> [ ]
type -> BLANK

str -> [lol]
type -> WORD

str -> [ ]
type -> BLANK

str -> [$coucou]
type -> VARIABLE

str -> [ ]
type -> BLANK

str -> [cou]
type -> S_QUOTE

str -> [lol]
type -> WORD //ne devrait pas plutôt être une variable ?

str -> [ ]
type -> BLANK

str -> [<]
type -> R_REDIRECT

str -> [hou]
type -> WORD

str -> [ ]
type -> BLANK

str -> [>>]
type -> W_APPEND_REDIRECT

str -> [lol]
type -> WORD

str -> [ ]
type -> BLANK

str -> [<]
type -> R_REDIRECT

str -> [d]
type -> WORD

str -> [ ]
type -> BLANK

str -> [<]
type -> R_REDIRECT

str -> [j]
type -> WORD

str -> [>]
type -> W_REDIRECT

str -> [l]
type -> WORD

str -> [ ]
type -> BLANK

str -> [(#)]
type -> WORD

str -> [ ]
type -> BLANK

str -> [|]
type -> PIPE

str -> [ ]
type -> BLANK

str -> [allo]
type -> WORD

str -> [ ]
type -> BLANK

str -> [cou$tata]
type -> S_QUOTE

str -> [agrougrou$pouah$akiya]
type -> D_QUOTE_VAR

***********
Segmentation fault (core dumped)

