11/11/2023 Ã  9h04
L'expander conserve les s_quote et d_quote vides, ce qui est un trÃ¨s bonne chose
Pendant les retouches de l'expander, il faut que Ã§a soit toujours le cas !

11/11/2023 Ã  06h49
Deux sujets au niveau de l'expander :
ğŸ§¨ - Pour les ambiguous_redirect, il faut non seulement prendre en compte les variables
inexistantes, mais aussi les variables spÃ©ciales


âœ… - En rÃ©flÃ©chissant aux fonctions env, export et unset, puis Ã  l'expander, je me suis dit
qu'il valait mieux rÃ©gler ces trois builtins avant de retoucher l'expander ; je m'explique :
L'expander va, notamment pour (tenter de) remplacer les variables par leur valeur,
interroger l'environnement de minishell, lequel sera (potentiellement) modifiÃ© au fil
des itÃ©rations successives aprÃ¨s un mÃªme dÃ©marrage du programme.
L'environnement doit Ã©galement pouvoir Ãªtre affichÃ© de deux maniÃ¨res diffÃ©rentes :
	- avec le builtin env ; les variables affichÃ©es dans un ordre un peu alÃ©atoire
	- avec le builtin export (sans argument) ; avec :
		- les variables natives en premier, triÃ©es dans l'ordre lexicographique
		- les variables ajoutÃ©es (par export), en second, triÃ©es dans l'ordre lexicographique
Il faut donc Ãªtre capable de distinguer les deux types de variable : natives et ajoutÃ©es.
Tu avais proposÃ© l'utilisation de deux listes chainÃ©es diffÃ©rentes ; ce qui permettrait
aisÃ©ment la distinction entre natives et ajoutÃ©es ; je pense que cette solution Ã  deux
listes est une bonne idÃ©e.
Cependant, elle a une implication au niveau de l'expander :
	l'expander devra donc interroger ces deux listes pour tenter de remplacer les variables
	par leur valeur.
Concernant unset : il faudra interroger les deux listes aussi.


âœ… 10/11/2023 Ã  18h35
Les erreurs classiques des redirections sont maintenant gÃ©rÃ©es
Il manque cependant les erreurs provoquÃ©es par les variables inexistantes ou spÃ©ciales
Je rÃ©alise que je perds une information lors de l'expander (que je ne peux pas rÃ©cupÃ©rer
Ã  l'exÃ©cuteur, vu que la fusion est passÃ©e par lÃ )
En fait, il me faudrait une nouvelle entrÃ©e dans l'e_expander_type :
enum	e_expander_type
{
	INIT_VALUE_EXP_CURRENT_TYPE,
	WORD_EXPANDED,
	R_ORIGIN_REDIRECT,
	LIMITER_HEREDOC,
	W_DEST_REDIRECT,
	WA_DEST_REDIRECT,
	PIPE_EXPANDED,
	HEREDOC_ERASED,
->	AMBIGUOUS_REDIRECT <-
};
Cette valeur de l'enum serait attribuÃ©e au noeud de l'exp_list correspondant dans le cas
suivant :
une fusion n'est le produit que d'une seule variable qui n'existe pas.
Dans ce cas, le nom de la variable doit Ãªtre conservÃ©e (ce qui est dÃ©jÃ  le cas, et tant mieux),
mais je ne sais pas, dans le cas d'une redirection, s'il s'agit d'un nom de variable
inexistante, ou si c'Ã©tait le contenu d'une s_quote, ou encore le rÃ©sultat d'une fusion de
plusieurs mots/caractÃ¨res

Tests autour des variables inexistantes et des ambiguous_redirect :
bash 3.2: > $lol
bash: $lol: ambiguous redirect
bash 3.2: < $lol$mdr
bash: $lol$mdr: ambiguous redirect
bash 3.2: < $lol""$mdr
bash: : No such file or directory
bash 3.2: < "$lol"
bash: : No such file or directory
bash 3.2: < $lol
bash: $lol: ambiguous redirect
bash 3.2: < $lol$mdr
bash: $lol$mdr: ambiguous redirect
bash 3.2: < $"lol"$mdr
bash: lol: No such file or directory
bash 3.2: < "$lol"$mdr
bash: : No such file or directory
bash 3.2: < "$lol$mdr"
bash: : No such file or directory
bash 3.2: < $lol""
bash: : No such file or directory
bash 3.2: < ""$lol
bash: : No such file or directory
bash 3.2: < ''$lol
bash: : No such file or directory
bash 3.2: < $lol''
bash: : No such file or directory
Tests autour des variables inexistantes et des ambiguous_redirect :
> $lol
bash: $lol: ambiguous redirect
< $lol$mdr
bash: $lol$mdr: ambiguous redirect
< $lol""$mdr
bash: : No such file or directory
< "$lol"
bash: : No such file or directory
< $lol
bash: $lol: ambiguous redirect
< $lol$mdr
bash: $lol$mdr: ambiguous redirect
< $"lol"$mdr
bash: lol: No such file or directory
< "$lol"$mdr
bash: : No such file or directory
< "$lol$mdr"
bash: : No such file or directory
< $lol""
bash: : No such file or directory
< ""$lol
bash: : No such file or directory
< ''$lol
bash: : No such file or directory
< $lol''
bash: : No such file or directory

(copiÃ© collÃ© des messages discords explicatifs)
En fait, tu as fait en sorte que les variables inexistantes disparaissent lorsqu'elles ne
sont pas l'objet de redirection. Aucun problÃ¨me de ce cÃ´tÃ© lÃ , c'est ce qu'o navait prÃ©vu,
et rien Ã  retoucher lÃ -dessus
On avait aussi prÃ©vu de conserver le nom de la variable dans le cas oÃ¹ elle n'existe pas,
 et qu'elle est l'objet d'une redirection ; Ã§a aussi c'est ce que l'on avait prÃ©vu,
  et c'est comme Ã§a que Ã§a foncitonne, et tant mieux aussi
LÃ  oÃ¹ j'ai un problÃ¨me, c'est qu'une fois Ã  l'exÃ©cutor, je ne sais pas distinguer
les deux cas suivants (par exemple) :
(la variable lol n'existe pas)
< '$lol'
ET
< $lol
ğŸ§¨ l'expander me sort la mÃªme chose en terme de texte, et c'est ce que l'on veut
Par contre, dans le premier cas, l'executor doit lire Ã  partir du fichier nommÃ© $lol
Alors que dans le deuxiÃ¨me cas, l'executor doit retourner une erreur "ambiguous redirect"
(Je me suis fait un peu mieux comprendre ?)
Donc, dans le cas oÃ¹ tu reÃ§ois < $lol dans l'expander,
tu conserves toujours le nom de la variable inexistante (rien Ã  changer de ce cÃ´tÃ©-lÃ ),
 mais au lieu de mettre l'enum     R_ORIGIN_REDIRECT,
 tu mettrais un nouveau AMBIGUOUS_REDIRECT
amel â€” Aujourdâ€™hui Ã  18:55
Ok mais c'est pour quel chevrons qu'on dooit faire ca ?
Spardaspirit â€” Aujourdâ€™hui Ã  18:55
tous sauf <<


ğŸ¥ 9/11/2023 Ã  18h38 CODE RETOUR

au dÃ©marrage : msh->return_code est Ã  0
lexer :
	si erreur :
		msh->return_code est modifiÃ© Ã  2
		pas de parser, expander ni executor
		Ã  la nouvelle itÃ©ration msh->return_code est donc toujours Ã  2
	sinon
		msh->return_code laissÃ© Ã  0
parser :
	mÃªme chose que le lexer
expander :
	si on parvient jusqu'Ã  l'expander, alors, $? est remplacÃ© par sa valeur
executor :
	si erreur :
		affichage de l'erreur (qui peut contenir l'actuelle valeur de msh->return_code)
		msh->return_code est assignÃ© Ã  l'erreur correspondante





âœ… 9/11/2023 Ã  16h05
Certes, << $toto entraine une erreur qui fait crash
mais $toto aussi :/


ğŸ¥ 9/11/2023 : Signaux
En mode interactif, le sujet prÃ©cise dÃ©jÃ  les comportements des trois signaux ;
Ctrl + C :
	(free entre deux itÃ©rations)
	affiche Ã  nouveau le prompt
	msh->return_code assignÃ© Ã  130
Ctrl + D :
	(free de TOUT)
	quitte minishell
	(question du msh->return_code non pertinente)
Ctrl + \ :
	RIEN
	msh->return_code laissÃ© Ã  0

Pendant l'exÃ©cution :
Ctrl + C :
	(free entre deux itÃ©rations)
	interrompt (kill certainement) tous les processus en cours
	affiche Ã  nouveau le prompt
	msh->return_code assignÃ© Ã  130
Ctrl + D :
	RIEN
	msh->return_code laissÃ© Ã  0
Ctrl + \ :
	mÃªme chose que Ctrl + C, sauf le msh->return_code assignÃ© Ã  131

Pendant la saisie d'un heredoc :
Ctrl + C :
	MÃªme chose que pendant l'exÃ©cution
Ctrl + D :
	MÃªme chose que Ctrl + C, sauf le msh->return_code laissÃ© Ã  0
Ctrl + \ :
	RIEN (la saisie du heredoc est maintenue, sans nouvelle ligne)
	AprÃ¨s la saisie du limiter, msh->return_code est toujours Ã  0



âœ… <> est un opÃ©rateur de redirection "lecture-Ã©criture" ; aprÃ¨s relecture attentive du sujet, il n'est pas Ã  implÃ©menter, contrairement Ã  ce que les tests des pages github peuvent sous-entendre
Ainsi, <> doit provoquer une syntax error chez nous
Je crois que nous l'avions dÃ©jÃ  notÃ©, mais au cas oÃ¹, un rappel (vu que je suis tombÃ© dessus dans les tests sur github).

ğŸ§¨ ls|cat ne fonctionne pas :
	le pipe n'est pas pris en compte
	l'expander sort juste deux mots d'affilÃ©e

Les commandes suivantes :

âœ… - premiÃ¨re commande : ls > lol
spardaspirit $> ls > lol
(WORD_EXPANDED)ls (W_DEST_REDIRECT)lol
spardaspirit $> Segmentation fault (core dumped)
// le Segmentation fault (core dumped) s'affiche tout seul dans le prompt,
// je ne l'ai pas saisi

âœ… - deuxiÃ¨me commande : echo coucou > mdr
(mÃªme erreur)

provoquent une segfault au moment du rÃ©affichage du prompt
valgrind indique une anomalie du ft_strlen (ah ouais, Ã  ce point ???)
cela semble Ãªtre uniquement le cas des lignes ne contenant aucun pipe
dÃ¨s qu'il y au moins un pipe, la segfault n'apparait plus


Contenu de notes.txt (fichier maintenant supprimÃ©) collÃ© ici :
A adapter et incure dans chaque fichier

#include "minishell.h"




Observations expander test:

âœ… //arrive lors de la premiÃ¨re saisie de prompt, mais pas durant les suivantes
spardaspirit $> e'c'ho lol
str = c
Segmentation fault (core dumped)

âœ… // pareil, lors de la premiÃ¨re saisie, mais pas durant les suivantes
spardaspirit $> lol lol
Segmentation fault (core dumped)

HypothÃ¨se : s'il y a plus de deux mots dans le premier prompt : segfault


âœ… // un seul chevron ouvert provoque une segfault,
	mÃªme aprÃ¨s plusieurs saisies d'autres prompts prÃ©cÃ©dents
spardaspirit $> <

______ main lexer_list ______
str -> [<]
type -> R_REDIRECT

***********
bash: syntax error near unexpected token 'newline'
Segmentation fault (core dumped)


âœ… //mÃªme problÃ¨me ici
spardaspirit $> <<

______ main lexer_list ______
str -> [<<]
type -> HEREDOC

***********
bash: syntax error near unexpected token 'newline'
Segmentation fault (core dumped)

// tous les chevrons provoquent le mÃªme type d'erreur menant Ã  une segfault


âœ… spardaspirit $> lol

______ main lexer_list ______
str -> [lol]
type -> WORD

***********

______ main expander_list ______
str -> [lol]
type -> WORD_EXPANDED
***********
âœ… spardaspirit $> > lol

______ main lexer_list ______
str -> [>]
type -> W_REDIRECT

str -> [ ]
type -> BLANK
Segmentation fault (core dumped)


AprÃ¨s de nombreux tests durant une mÃªme exÃ©cution (donc aprÃ¨s plusieurs saisies successives de prompts),
	les chevrons tout seul fonctionnent


âœ… Je remarque aussi que l'expander ne s'affiche plus.
En regardant le main.c,
	je remarque que le parser et l'expander ne se dÃ©clenchent que selon la valeur d'une variable dans msh qui ne semble pas initialisÃ©e.
La valeur de cette variable n'est ajustÃ©e que dans le lexer (lexer_create_list),
	et dans le parser. Elle n'est pas initialisÃ©e Ã  la crÃ©ation de la structure msh.


spardaspirit $> cd lol $coucou 'cou'$lol <hou >>lol <d <j>l  (#) | allo 'cou$tata' "agrougrou$pouah$akiya"
str = cou
str = cou$tata

______ main lexer_list ______
str -> [cd]
type -> WORD

str -> [ ]
type -> BLANK

str -> [lol]
type -> WORD

str -> [ ]
type -> BLANK

str -> [$coucou]
type -> VARIABLE

str -> [ ]
type -> BLANK

str -> [cou]
type -> S_QUOTE

str -> [lol]
type -> WORD //ne devrait pas plutÃ´t Ãªtre une variable ?

str -> [ ]
type -> BLANK

str -> [<]
type -> R_REDIRECT

str -> [hou]
type -> WORD

str -> [ ]
type -> BLANK

str -> [>>]
type -> W_APPEND_REDIRECT

str -> [lol]
type -> WORD

str -> [ ]
type -> BLANK

str -> [<]
type -> R_REDIRECT

str -> [d]
type -> WORD

str -> [ ]
type -> BLANK

str -> [<]
type -> R_REDIRECT

str -> [j]
type -> WORD

str -> [>]
type -> W_REDIRECT

str -> [l]
type -> WORD

str -> [ ]
type -> BLANK

str -> [(#)]
type -> WORD

str -> [ ]
type -> BLANK

str -> [|]
type -> PIPE

str -> [ ]
type -> BLANK

str -> [allo]
type -> WORD

str -> [ ]
type -> BLANK

str -> [cou$tata]
type -> S_QUOTE

str -> [agrougrou$pouah$akiya]
type -> D_QUOTE_VAR

***********
Segmentation fault (core dumped)

